/*******************************************************************
	FILE:		MFDataScanner.m
	
	COPYRIGHT:
		Copyright 2007-2008, the MacFire.org team.
		Use of this software is governed by the license terms
		indicated in the License.txt file (a BSD license).
	
	DESCRIPTION:
		A class to scan specific kinds of data.  It uses some rules
		similar to Xfire encoding rules.  It scans data generated by
		an MFDataEmitter.
	
	HISTORY:
		2008 04 06  Changed copyright to BSD license.
		2007 12 02  Added copyright notice.
		2007 12 01  Created.
*******************************************************************/

#import "MFDataScanner.h"

#define CHECK_LENGTH_EX( _need, _desc ) if( (_cur + (_need)) > _end ) [NSException raise:@"ScannerException" format:@"Not enough bytes to scan %@ (%u)", (_desc), (_end-_cur)]

@implementation MFDataScanner

+ (id)scannerWithData:(NSData *)data
{
	return [[[MFDataScanner alloc] initWithData:data] autorelease];
}

- (id)initWithData:(NSData *)data
{
	self = [super init];
	if( self )
	{
		_data = [data retain];
		_start = [_data bytes];
		_cur = _start;
		_end = _start + [_data length];
	}
	return self;
}

- (void)dealloc
{
	[_data release];
	[super dealloc];
}

- (UInt8)scanUInt8
{
	CHECK_LENGTH_EX( 1, @"int8" );
	
	UInt8 v = *_cur;
	
	_cur++;
	return v;
}

- (UInt16)scanUInt16
{
	CHECK_LENGTH_EX( 2, @"int16" );
	
	UInt16 v = (
		((UInt16)_cur[0]) |
		(((UInt16)_cur[1]) << 8)
		);
	
	_cur += 2;
	return v;
}

- (UInt32)scanUInt32
{
	CHECK_LENGTH_EX( 4, @"int32" );
	
	UInt32 v = (
		((UInt32)_cur[0]) |
		(((UInt32)_cur[1]) << 8) |
		(((UInt32)_cur[2]) << 16) |
		(((UInt32)_cur[3]) << 24)
		);
	
	_cur += 4;
	return v;
}

- (NSString *)scanString
{
	UInt16 len = [self scanUInt16];
	NSString *s;
	
	CHECK_LENGTH_EX( len, @"string" );
	
	if( len > 0 )
	{
		s = [[[NSString alloc] initWithBytes:_cur
			length:len
			encoding:NSUTF8StringEncoding] autorelease];
		_cur += len;
	}
	else
	{
		s = [NSString string];
	}
	
	return s;
}

- (NSData *)scanData
{
	UInt32 len = [self scanUInt32];
	NSData *d;
	
	CHECK_LENGTH_EX( len, @"data" );
	
	if( len >  0)
	{
		d = [NSData dataWithBytes:_cur length:len];
		_cur += len;
	}
	else
	{
		d = [NSData data];
	}
	
	return d;
}

@end
